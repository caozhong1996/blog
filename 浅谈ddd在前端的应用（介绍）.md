# 浅谈ddd在前端的应用（介绍）

## 前言

为什么要建模；怎么建模才合理；“领域”模型具体指什么。

那么，为什么要建模？第一，要把心智模型提取出来，显性化，让不同的人对业务的理解达成一致；第二，要归类复用，避免重复的工作，让人可以关注更高层面的事务。

软件工程师并没有创造新的东西，只不过是数字世界的砖瓦工，计算机系统中合乎逻辑的过程，停电后人肉使用纸和笔一样合乎逻辑。

领域，指的特定行业或者场景下的业务逻辑。

DDD 中的模型是指反应 IT 系统的业务逻辑和状态的对象，是从具体业务（领域）中提取出来的，因此又叫做领域模型。通过对实际业务出发，而非马上关注组件、页面设计。通过识别出固定的模式，并将这些业务逻辑的承载者抽象到一个模型上。这个模型负责处理业务逻辑，并表达当前的系统状态。这个过程就是领域驱动设计。

我们做的计算机系统实际上，是替代了现实世界中的一些操作。按照面向对象设计的话，我们的系统是一个电子餐厅。现实餐厅中的实体，应该对应到我们的系统中去，用于承载业务，例如收银员、顾客、厨师、餐桌、菜品，这些虚拟的实体表达了系统的状态，在某种程度上就能指代系统，这就是模型，如果找到了这些元素，就很容易设计出软件。后来，如果我什么业务逻辑想不清楚，我就会把电断掉，假装自己是服务员，用纸和笔走一边业务流程。分析业务，设计领域模型，编写代码。这就是领域驱动设计的基本过程。

组件里面随便一个方法直接就修改了业务逻辑，保持业务逻辑的完整，完全凭程序员对系统的了解。

使用领域驱动设计还有一个好处，我们可以通过隔离这些技术细节，先讲业务逻辑建模，然后再完成技术实现，因为业务模型已经建立，技术细节无非就是响应用户操作和划分组件。

## 贫血模型 vs 充血模型

### 贫血模型

`贫血模型`是指使用的领域对象中只有setter和getter方法，它虽然比较直接，但是我们很难知道对象的变更过程（为什么要变，变得条件是什么，怎么变得，变成什么样了）。因为业务逻辑都在组件中，我们就很难了解对象状态的变更过程，当组件之间的数据存在互相流动时，就更难理解对象状态的变更过程了。同时，组件中持有大量对象的状态处理逻辑，也会出现很多重复的代码。

缺点：逻辑集中在C层，导致C太过厚重。最常见的烂做法就是将逻辑全部写在组件的methods中，组件应该专注于视图层

### 充血模型

`充血模型`充血模型将大多数业务逻辑放在领域对象中，业务逻辑只是完成对业务逻辑的封装、权限等的处理。比较符合面向对象。

### 补充

真正自然的“领域模型”应该是这样的，如果对象的某些行为在任何场景都是通用的，那么就放在领域中去，将其绑定，这是尊重“共性”的约束；如果对象的某些依赖于具体的场景，那么则在具体的场景中注入相应的行为，赋予对象相应的角色，这是尊重“个性”的自由。所以，对象的行为该不该放入“领域模型”，我们要先分析一下这些行为是对象所固有的，还是依赖于场景的，如果是固有的，即是共性的，就放入领域模型(domain)，如果不是则延迟在具体的场景（service）中注入，赋予其角色的个性(DCI)。

## 总结

凡事必有特殊，我们遵循DDD，并不意味着DDD必须原模原样的在前端实现。DDD的最佳实践都是针对后端的，后端开发存在的特征，前端可能不存在，前端的特征，后端也可能不存在，因此，以DDD为设计思想，同时针对前端特殊性做出一些调整，也是应该的。
